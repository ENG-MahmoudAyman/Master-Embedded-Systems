/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
#include "Stm32F103x8.h"
#include "GPIO_Stm32F103x8.h"
#include "EXTI_Stm32F103x8.h"
#include "UART_Stm32F103x8.h"
#include "SPI_Stm32F103x8.h"
#include "core_cm3.h"

#include "Scheduler.h"


void TASK1();
void TASK2();
void TASK3();

Task_Ref MY_RTOS_Task1;
Task_Ref MY_RTOS_Task2;
Task_Ref MY_RTOS_Task3;
Mutex_Ref Mutex1;

uint8 Task1Indic,Task2Indic,Task3Indic;

uint8 payload[3] = {1,2,3};

int main(void)
{	MY_RTOS_ERROR_ID error = NO_ERROR;
	HW_init();
	MY_RTOS_init();
	//Configure Task1
	MY_RTOS_Config_Task( MY_RTOS_Task1 ,"MY RTOS Task1" , 3, TASK1, 1024);
	/*strcpy(MY_RTOS_Task1.TaskName, "MY RTOS Task1");
	MY_RTOS_Task1.Priority = 3;
	MY_RTOS_Task1.p_TaskEntry = TASK1;
	MY_RTOS_Task1.Stack_Size = 1024;*/

	//Configure Task2
	MY_RTOS_Config_Task( MY_RTOS_Task2 ,"MY RTOS Task2" , 2, TASK2, 1024);
	/*strcpy(MY_RTOS_Task2.TaskName, "MY RTOS Task2");
	MY_RTOS_Task2.Priority = 2;
	MY_RTOS_Task2.p_TaskEntry = TASK2;
	MY_RTOS_Task2.Stack_Size = 1024;*/

	//Configure Task3
	MY_RTOS_Config_Task( MY_RTOS_Task3 ,"MY RTOS Task3" , 1, TASK3, 1024);
	/*strcpy(MY_RTOS_Task3.TaskName, "MY RTOS Task3");
	MY_RTOS_Task3.Priority = 1;
	MY_RTOS_Task3.p_TaskEntry = TASK3;
	MY_RTOS_Task3.Stack_Size = 1024;*/

	//configure Mutex1
	MY_RTOS_Config_Mutex(Mutex1, "Mutex Task 1&3", 3 , payload);
	/*strcpy(Mutex1.Mutex_Name,"Mutex Task 1&3");
	Mutex1.Payload_Size = 3;
	Mutex1.Ppayload = payload;*/

	error += MY_RTOS_Create_Task(&MY_RTOS_Task1);
	error += MY_RTOS_Create_Task(&MY_RTOS_Task2);
	error += MY_RTOS_Create_Task(&MY_RTOS_Task3);

	MY_RTOS_Activate_Task(&MY_RTOS_Task1);
	//MY_RTOS_Activate_Task(&MY_RTOS_Task2);
	//MY_RTOS_Activate_Task(&MY_RTOS_Task3);

	MY_RTOS_StartOS();

	while (1) {

	}


}

void TASK1(){

	static int count = 0;
	while(1){
		Task1Indic ^= 1;
		count++;
		if(count == 500){
			MY_RTOS_Acquire_Mutex(&Mutex1, &MY_RTOS_Task1);
			MY_RTOS_Activate_Task(&MY_RTOS_Task2);
		}
		if(count == 1000){
			count = 0;
			MY_RTOS_Release_Mutex(&Mutex1);
		}
	}

}

void TASK2(){

	static int count = 0;
	while(1){
		Task2Indic ^= 1;
		count++;
		if(count == 500){
			MY_RTOS_Activate_Task(&MY_RTOS_Task3);
		}
		if(count == 1000){
			MY_RTOS_Terminate_Task(&MY_RTOS_Task2);
			count = 0;
		}
	}

}

void TASK3(){
	static int count = 0;
	while(1){
		Task3Indic ^= 1;
		count++;
		if(count == 50){
			MY_RTOS_Acquire_Mutex(&Mutex1, &MY_RTOS_Task3);
			MY_RTOS_Acquire_Mutex(&Mutex1, &MY_RTOS_Task3);
		}
		if(count == 1000){
			MY_RTOS_Acquire_Mutex(&Mutex1, &MY_RTOS_Task3);
			MY_RTOS_Release_Mutex(&Mutex1);
			MY_RTOS_Terminate_Task(&MY_RTOS_Task3);
			count = 0;
		}
	}

}





