/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
#include "Stm32F103x8.h"
#include "GPIO_Stm32F103x8.h"
#include "EXTI_Stm32F103x8.h"
#include "UART_Stm32F103x8.h"

#define frequency 8000000UL
#define UART_Test
	uint8 Character;
void MyIRQHandler(void){
	if (Rcomplete(USART1)) {
		MCAL_USART_Read(USART1, (uint16*) &(Character), Disable);
		MCAL_UART_Send(USART1, (uint16*) &(Character), Enable);
	}
}



void delay_ms(uint32 Tms){
	uint32 i,j=Tms*(frequency/1000);
	for(i=0;i<j;i++);
}

#ifdef UART_Test

int main(void)
{	USART_PinConfig_t USART_Config = {USART_Mode_RX_TX, USART_BaudRate_115200,USART_Word_Length_8B, USART_Parity_Disabled, USART_StopBits_1, USART_FlowCTL_None, USART_IRQ_Enable_RXNE, MyIRQHandler};
	MCAL_UART_Init(USART1, &USART_Config);
	while(1){
	}
}


#endif //UART_Test

#ifdef EXTI_Test
void init_GPIO(){
	//PB1 OUTPUT PUSH_PULL
	MCAL_GPIO_Init(GPIOB,&PB1);

}
int main(void)
{
	init_RCC();
	init_GPIO();
	EXTI_PinConfig_t PB0 = {EXTI0_PB0, EXTI_Trigger_RISING, EXTI_IRQ_Enable,MyIRQHandler};
	MCAL_EXTI_Init(&PB0);
	while(1);
}
void MyIRQHandler(void){
	MCAL_GPIO_TogglePin(GPIOB,(PB1.GPIO_PinNumber));
}

#endif //EXTI_Test


#ifdef GPIO_Test

GPIO_PinConfig_t PB13 = {GPIO_PIN_13,GPIO_MODE_OUTPUT_PP,GPIO_Output_Speed_10M};
GPIO_PinConfig_t PB1 = {GPIO_PIN_1,GPIO_MODE_OUTPUT_PP,GPIO_Output_Speed_10M};
GPIO_PinConfig_t PA13 = {GPIO_PIN_13,GPIO_MODE_INPUT_FLO,};
GPIO_PinConfig_t PA1 = {GPIO_PIN_1,GPIO_MODE_INPUT_FLO,};

void init_GPIO(){
	//PB13 OUTPUT PUSH_PULL
	MCAL_GPIO_Init(GPIOB,&PB13);
	//PB1 OUTPUT PUSH_PULL
	MCAL_GPIO_Init(GPIOB,&PB1);
	//PA13 INPUT Floating
	MCAL_GPIO_Init(GPIOA,&PA13);
	//PA1 INPUT Floating
	MCAL_GPIO_Init(GPIOA,&PA1);
}
int main(void)
{
	init_RCC();
	init_GPIO();
	uint32 old_state = 1;
	while(1){
		if(MCAL_GPIO_ReadPin(GPIOA,(PA1.GPIO_PinNumber))== GPIO_PIN_LOW && (old_state)){
			old_state = 0;
			MCAL_GPIO_TogglePin(GPIOB,(PB1.GPIO_PinNumber));
		}
		else if(MCAL_GPIO_ReadPin(GPIOA,(PA1.GPIO_PinNumber))== GPIO_PIN_HIGH){
			old_state = 1;
		}
		if(MCAL_GPIO_ReadPin(GPIOA,(PA13.GPIO_PinNumber))== GPIO_PIN_HIGH){
			MCAL_GPIO_TogglePin(GPIOB,(PB13.GPIO_PinNumber));
		}
		delay_ms(10);
	}
}
#endif //GPIO_Test
