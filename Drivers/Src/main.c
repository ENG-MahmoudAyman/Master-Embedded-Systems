/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
#include "Stm32F103x8.h"
#include "GPIO_Stm32F103x8.h"
#include "EXTI_Stm32F103x8.h"

#define frequency 8000000UL
#define EXTI_Test
void MyIRQHandler(void);
//GPIO_PinConfig_t PB13 = {GPIO_PIN_13,GPIO_MODE_OUTPUT_PP,GPIO_Output_Speed_10M};
GPIO_PinConfig_t PB1 = {GPIO_PIN_1,GPIO_MODE_OUTPUT_PP,GPIO_Output_Speed_10M};
//GPIO_PinConfig_t PA13 = {GPIO_PIN_13,GPIO_MODE_INPUT_FLO,};
//GPIO_PinConfig_t PA1 = {GPIO_PIN_1,GPIO_MODE_INPUT_FLO,};



void delay_ms(uint32 Tms){
	uint32 i,j=Tms*(frequency/1000);
	for(i=0;i<j;i++);
}

void init_RCC(){
	//GPIOA Clock Enable
	GPIOA_CLK_EN();
	//GPIOB Clock Enable
	GPIOB_CLK_EN();
	//AFIO Clock Enable
	AFIO_CLK_EN();

}

#ifdef EXTI_Test
void init_GPIO(){
	//PB1 OUTPUT PUSH_PULL
	MCAL_GPIO_Init(GPIOB,&PB1);

}
int main(void)
{
	init_RCC();
	init_GPIO();
	EXTI_PinConfig_t PB0 = {EXTI0_PB0, EXTI_Trigger_RISING, EXTI_IRQ_Enable,MyIRQHandler};
	MCAL_EXTI_Init(&PB0);
	while(1);
}
void MyIRQHandler(void){
	MCAL_GPIO_TogglePin(GPIOB,(PB1.GPIO_PinNumber));
}

#endif //EXTI_Test


#ifdef GPIO_Test
void init_GPIO(){
	//PB13 OUTPUT PUSH_PULL
	MCAL_GPIO_Init(GPIOB,&PB13);
	//PB1 OUTPUT PUSH_PULL
	MCAL_GPIO_Init(GPIOB,&PB1);
	//PA13 INPUT Floating
	MCAL_GPIO_Init(GPIOA,&PA13);
	//PA1 INPUT Floating
	MCAL_GPIO_Init(GPIOA,&PA1);
}
int main(void)
{
	init_RCC();
	init_GPIO();
	uint32 old_state = 1;
	while(1){
		if(MCAL_GPIO_ReadPin(GPIOA,(PA1.GPIO_PinNumber))== GPIO_PIN_LOW && (old_state)){
			old_state = 0;
			MCAL_GPIO_TogglePin(GPIOB,(PB1.GPIO_PinNumber));
		}
		else if(MCAL_GPIO_ReadPin(GPIOA,(PA1.GPIO_PinNumber))== GPIO_PIN_HIGH){
			old_state = 1;
		}
		if(MCAL_GPIO_ReadPin(GPIOA,(PA13.GPIO_PinNumber))== GPIO_PIN_HIGH){
			MCAL_GPIO_TogglePin(GPIOB,(PB13.GPIO_PinNumber));
		}
		delay_ms(10);
	}
}
#endif //GPIO_Test
